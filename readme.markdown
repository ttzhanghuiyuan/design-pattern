# 设计模式的七大原则

* 1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

* 2、里氏替换原则（Liskov Substitution Principle）（？子类可以替换基类？？） 里氏代换原则中说：任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

* 3、依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。

* 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。

* 5、单一职责原则（Single Responsibility Principle）：一个类负责一项职责。

* 6、迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。高内聚 低耦合 – high cohesion low coupling

* 7、组合/聚合复用原则（Composition/Aggregation Reuse Principle，CARP)）：尽量使用组合和聚合少使用继承的关系来达到复用的原则。


# 24 种设计模式

## 一、创建型模式

* 单例模式（Singleton Pattern）： 确保一个类只有一个实例，可以直接访问，不需要实例化该类的对象。

* 工厂模式（Factory Pattern）：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类。即一个工厂类，管理其余的所有子类，要想实例化子类，需通过工厂类的方法。

* 抽象工厂模式（Abstract Factory Pattern）：可以简单理解为如果有多个工厂模式，那么需要用抽象工厂来管理。

* 建造者模式（Builder Pattern）：使用多个简单的对象一步一步构建成一个复杂的对象（有点复杂）。

* 原型模式（Prototype Pattern）：当需要创建重复的对象时，为了保证性能和效率，它提供了一种创建对象的最佳方式。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

## 二、结构型模式


* 1、装饰器模式（Decorator Pattern）：动态地将责任附加到对象上, 若要扩展功能, 装饰者提供了比继承更有弹性的替代方案.

* 2、适配器模式（Adapter Pattern）：将一个类的接口, 转换成客户期望的另一个接口. 适配器让原本接口不兼容的类可以合作无间. 对象适配器使用组合, 类适配器使用多重继承.

* 3、代理模式（Proxy Pattern）：为另一个对象提供一个替身或占位符以控制对这个对象的访问.

* 4、桥接模式（Bridge Pattern）： 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变.

* 5、组合模式（Composite Pattern）：允许你将对象组合成树形结构来表现”整体/部分”层次结构. 组合能让客户以一致的方式处理个别对象以及对象组合.

* 6、外观模式（Facade Pattern）：提供了一个统一的接口, 用来访问子系统中的一群接口. 外观定义了一个高层接口, 让子系统更容易使用.

* 7、享元模式（Flyweight Pattern）：如想让某个类的一个实例能用来提供许多”虚拟实例”, 就使用蝇量模式.

## 三、行为型模式

* 1、观察者模式（Observer Pattern）： 在对象之间定义一对多的依赖, 这样一来, 当一个对象改变状态, 依赖它的对象都会收到通知, 并自动更新.

* 2、责任链模式（Chain of Responsibility Pattern）： 通过责任链模式, 你可以为某个请求创建一个对象链. 每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象.

* 3、迭代器模式（Iterator Pattern）：迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

* 5、中介者模式（Mediator Pattern）：使用中介者模式来集中相关对象之间复杂的沟通和控制方式.

* 6、备忘录模式（Memento Pattern）：当你需要让对象返回之前的状态时(例如, 你的用户请求”撤销”), 你使用备忘录模式.

* 8、状态模式（State Pattern）：允许对象在内部状态改变时改变它的行为, 对象看起来好象改了它的类.

* 9、策略模式（Strategy Pattern）：定义了算法族, 分别封闭起来, 让它们之间可以互相替换, 此模式让算法的变化独立于使用算法的客户.

* 10、模板模式（Template Pattern）： 在一个方法中定义一个算法的骨架, 而将一些步骤延迟到子类中. 模板方法使得子类可以在不改变算法结构的情况下, 重新定义算法中的某些步骤.

* 11、访问者模式（Visitor Pattern）：当你想要为一个对象的组合增加新的能力, 且封装并不重要时, 就使用访问者模式.

# 个人感悟

我愿意将7种设计原则称为内功，21种具体设计模式称为招式。内功一成在写代码的时候，就有高内聚低耦合的潜意识，招式能帮助我们在经典场景上用成熟的方式去解决问题。